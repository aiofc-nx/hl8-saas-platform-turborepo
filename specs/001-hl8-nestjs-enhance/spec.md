# Feature Specification: NestJS 基础设施模块

**Feature Branch**: `001-hl8-nestjs-enhance`  
**Created**: 2025-10-11  
**Status**: Draft  
**Package Name**: `@hl8/nestjs-infra`  
**Input**: User description: "NestJS 基础设施模块：目标是为 NestJS 应用提供企业级基础设施功能，包括：自定义 Fastify 适配器、多租户能力、缓存功能、统一异常处理机制、集成 Pino 日志、统一配置管理等"

<!--
  重要提示：本规范遵循 `docs/definition-of-terms.mdc` 中定义的统一术语，
  确保业务需求描述与技术实现使用相同的领域语言（Ubiquitous Language）。
  核心术语：Platform（平台）、Tenant（租户）、Organization（组织）、Department（部门）、User（用户）。
-->

## 项目定位

**项目位置**: `libs/nestjs-infra`  
**项目类型**: 服务端基础设施库  
**包名**: `@hl8/nestjs-infra`  
**目标用途**: 为 HL8 SAAS 平台的所有服务端应用提供统一的基础设施能力

根据项目 Monorepo 组织原则：

- `libs/`: 服务端的业务库、领域模块、依赖库
- 本模块作为服务端基础设施库，放置在 `libs/` 目录下
- 为平台内所有服务端应用（如认证服务、租户管理服务、组织管理服务等）提供共享能力

## 项目背景与整合需求

### 背景说明

本项目旨在整合原有分散在多个独立包中的基础设施功能，以降低依赖复杂度、简化使用方式、统一版本管理。

### 原有架构问题

**分散的独立包**（位于 `backup/` 目录）：

1. `@hl8/cache` - 基于 Redis 的缓存模块，支持租户隔离
2. `@hl8/config` - 类型安全的配置管理模块
3. `@hl8/logger` - 基于 Pino 的日志模块
4. `@hl8/isolation` - 多租户上下文管理模块
5. `@hl8/fastify-pro` - 企业级 Fastify 适配器
6. `@hl8/common` - 通用工具模块
7. `@hl8/utils` - 工具函数模块

**整合目标包名**: `@hl8/nestjs-infra`（infrastructure 的标准缩写）

**存在的问题**：

- ❌ **依赖关系复杂**: 模块间存在链式依赖（fastify-pro → isolation → common/config/logger → ...）
- ❌ **使用繁琐**: 需要同时导入多个包，配置重复
- ❌ **版本管理困难**: 多个包的版本需要保持兼容，升级困难
- ❌ **技术债务**: 所有旧包使用 CommonJS（`type: "commonjs"`），违反宪章要求
- ❌ **架构不清晰**: 未遵循 Clean Architecture 分层，可能存在贫血模型

### 整合目标

**统一到 `@hl8/nestjs-infra`**：

- ✅ **降低依赖复杂度**: 从5个独立包整合为1个统一包，内部模块化
- ✅ **简化使用**: 统一的导入路径和配置方式
- ✅ **统一版本管理**: 一个版本号管理所有功能
- ✅ **技术升级**: 从 CommonJS 迁移到 NodeNext，启用严格模式
- ✅ **架构升级**: 应用 Clean Architecture + DDD 充血模型 + CQRS + ES + EDA
- ✅ **提升质量**: 测试覆盖率 ≥ 80%，完整的 TSDoc 注释

### 整合范围

| 原包名             | 核心功能                                    | 整合后位置                | 优先级 | 状态       |
| ------------------ | ------------------------------------------- | ------------------------- | ------ | ---------- |
| **@hl8/common** ⭐ | **统一异常处理（RFC7807）、值对象、装饰器** | **exceptions/ + shared/** | **P0** | **待整合** |
| @hl8/multi-tenancy | 5层级数据隔离（平台/租户/组织/部门/用户）   | **isolation/**（重命名）  | P1     | 待整合     |
| @hl8/cache         | Redis 缓存、租户隔离缓存、装饰器            | caching/                  | P1     | 待整合     |
| @hl8/fastify-pro   | Fastify 适配器、中间件、插件                | fastify/                  | P1     | 待整合     |
| @hl8/config        | 类型安全配置、多格式加载、验证              | configuration/            | P1     | 待整合     |
| @hl8/logger        | Pino 日志、结构化日志                       | logging/                  | P1     | 部分已完成 |

**详细评估报告**: 参见 [analysis/legacy-modules-assessment.md](./analysis/legacy-modules-assessment.md)

### 整合策略

**分阶段迁移**：

**Phase 0 - 基础设施优先**（P0，预计 1 周）⭐ **CRITICAL**：

- **统一异常处理系统**（来自 common） - **必须首先完成**
  - AbstractHttpException 基类
  - 通用异常类（GeneralNotFoundException、GeneralBadRequestException、GeneralInternalServerException）
  - 异常过滤器（HttpExceptionFilter、AnyExceptionFilter）
  - 消息提供者（ExceptionMessageProvider）
  - RFC7807 标准响应格式
- EntityId 值对象（来自 common）
- 通用类型定义、枚举、常量（来自 common）

**Phase 1 - 核心功能**（P1，预计 2-3 周）：

- 日志服务（来自 logger，依赖异常处理）
- 数据隔离服务（来自 multi-tenancy，重命名为 isolation，依赖异常处理）
- Fastify 适配器基础功能（来自 fastify-pro）
- 缓存核心功能（来自 cache，依赖异常处理）

**Phase 2 - 完整功能**（P2，预计 2-3 周）：

- 配置管理（来自 config）
- 缓存装饰器（@Cacheable、@CacheEvict、@CachePut）
- 装饰器支持（@Public，来自 common）
- 守卫（来自 common）
- 监控和健康检查
- 高级中间件（限流、熔断器、安全）

**Phase 3 - 优化完善**（P3，预计 1-2 周）：

- 性能优化（缓存预热、连接池）
- 监控增强（指标收集、告警）
- 文档完善

**为什么异常处理必须优先？**

- ✅ 所有模块都依赖异常处理机制
- ✅ 提供统一的错误响应格式（RFC7807标准）
- ✅ 与 Swagger 集成，自动生成 API 文档
- ✅ 结构化日志记录和错误追踪
- ✅ 没有异常处理，其他模块无法正常工作

### 技术迁移要求

**从旧代码迁移必须满足**：

1. ✅ **模块系统**: CommonJS → NodeNext (`type: "module"`, `module: "NodeNext"`)
2. ✅ **TypeScript 严格模式**: 启用 `strict: true`、`strictNullChecks: true`、`noImplicitAny: true`
3. ✅ **DDD 充血模型**: 业务逻辑在领域对象内部，禁止贫血模型
4. ✅ **Clean Architecture**: 四层架构清晰分离，依赖关系正确
5. ✅ **测试覆盖率**: ≥ 80%，单元测试 + 集成测试
6. ✅ **TSDoc 注释**: 完整的中文注释，描述业务规则与逻辑
7. ✅ **any 类型使用**: 遵循宪章第 IX 条原则，严格控制 any 类型使用

### 参考资料

- **旧代码位置**: `backup/` 目录
- **评估分析**: `specs/001-hl8-nestjs-enhance/analysis/legacy-modules-assessment.md`
- **项目宪章**: `.specify/memory/constitution.md`
- **后端项目模板**: `docs/backend-project-template.md`

## 架构设计原则

### 重要说明：基础设施库不遵循 Clean Architecture 分层

**`@hl8/nestjs-infra` 的定位**：

- ✅ **通用基础设施库**：类似于 `@nestjs/common`、`@nestjs/core`
- ✅ **功能导向设计**：按功能模块组织代码（caching、configuration、isolation 等）
- ✅ **技术实现层**：本身就是业务应用的"基础设施层"
- ❌ **不是业务应用**：不遵循 Clean Architecture 的四层架构（领域层、应用层、基础设施层、接口层）

**为什么不遵循 Clean Architecture？**

1. **Clean Architecture 适用于业务应用**：
   - 目的是分离业务逻辑和技术细节
   - `@hl8/nestjs-infra` 本身就是"技术细节"层
   - 它为业务应用提供技术能力，而非实现业务逻辑

2. **功能导向更适合基础设施库**：
   - 每个功能模块独立、高内聚
   - 模块间低耦合，最小化依赖
   - 便于按需导入和使用

3. **参考业界标准库**：
   - `@nestjs/*` 系列库都采用功能导向
   - `express`、`fastify` 等库也是功能导向
   - 基础设施库的通用做法

### 本模块遵循的设计原则

**1. 功能模块化**：

- 按功能组织代码（caching、configuration、logging、isolation、fastify）
- 每个功能模块包含该功能的所有代码（服务、装饰器、类型、工具）
- 模块间通过明确的接口通信

**2. 高内聚低耦合**：

- 每个功能模块独立，职责清晰
- 最小化模块间依赖
- 公共代码放在 `shared/` 或 `utils/`

**3. 可复用性优先**：

- 设计为可被任何 NestJS 应用使用
- 无业务逻辑硬编码
- 提供灵活的配置选项

**4. 领域模型分离**：

- 业务领域概念（实体、值对象、事件）放在 `shared/` 目录
- 明确标识为"共享领域模型"
- 便于后续迁移到业务模块或 `shared-kernel`

**5. TypeScript 严格模式**：

- 遵循宪章要求的 NodeNext 模块系统
- 启用严格类型检查（strict、strictNullChecks、noImplicitAny）
- 严格控制 any 类型使用

**6. 测试驱动**：

- 单元测试覆盖率 ≥ 80%
- 单元测试与源代码同目录（`.spec.ts`）
- 集成测试放在 `__tests__/` 目录

**7. 完整的文档**：

- 所有公共 API 有完整的 TSDoc 注释
- 使用中文注释，描述功能和使用场景
- 提供使用示例

### 关于 shared/ 目录的特别说明

**shared/ 包含什么？**

- 领域实体（如 `IsolationContext`）
- 值对象（如 `TenantId`、`OrganizationId`、`DepartmentId`）
- 领域事件（如 `IsolationContextCreatedEvent`）
- 通用类型定义和异常

**为什么需要 shared/？**

1. **过渡性设计**：
   - 多租户隔离涉及的概念既是技术实现也是业务概念
   - 暂时放在基础设施库中，便于快速整合
   - 明确标识为"共享领域模型"，便于后续迁移

2. **后续迁移路径**：
   - **方案 A**：迁移到 `libs/shared-kernel`（DDD Shared Kernel 模式）
   - **方案 B**：迁移到具体业务模块（如 `libs/tenant-management`）
   - 迁移后，`nestjs-enhance` 依赖业务模块提供的领域模型

3. **迁移时机**：
   - Phase 1-2：暂时保留在 shared/，快速完成整合
   - Phase 3：评估是否需要迁移
   - 未来：当有多个业务模块需要共享时迁移

### 与业务应用的关系

**依赖关系**（未来架构）：

```text
业务应用（遵循 Clean Architecture）
    ↓
libs/tenant-management（业务模块，DDD + Clean Architecture）
    ↓
libs/shared-kernel（共享领域模型，DDD Shared Kernel）
    ↓
libs/nestjs-infra（基础设施库，功能导向）
```

**职责划分**：

| 层次           | 职责                       | 架构模式                                   |
| -------------- | -------------------------- | ------------------------------------------ |
| 业务应用       | 实现业务用例，提供用户接口 | Clean Architecture + DDD + CQRS + ES + EDA |
| 业务模块       | 实现领域逻辑，定义聚合根   | Clean Architecture + DDD                   |
| 共享内核       | 定义共享领域概念           | DDD Shared Kernel                          |
| **基础设施库** | **提供技术能力**           | **功能导向**                               |

### 多层级数据隔离支持

**统一语言体系**：

- 遵循宪章定义的统一术语（Platform、Tenant、Organization、Department、User）
- 支持5个隔离层级：平台级、租户级、组织级、部门级、用户级
- 支持企业租户、社群租户、团队租户、个人租户四种租户类型

**5个隔离层级详解**：

1. **平台级**（Platform）：
   - 隔离标识：无（所有标识符为空）
   - 数据归属：属于平台自身，跨租户共享
   - 典型数据：平台推广数据、运营数据、系统配置、全局统计、平台模板
   - 访问权限：仅平台管理员可访问
   - 缓存键示例：`hl8:cache:platform:promotion:banner-1`

2. **租户级**（Tenant）：
   - 隔离标识：tenantId
   - 数据归属：属于租户，租户内所有用户可见
   - 典型数据：租户配置、租户统计、租户级资源
   - 访问权限：租户内用户可访问
   - 缓存键示例：`hl8:cache:tenant:t123:config`

3. **组织级**（Organization）：
   - 隔离标识：tenantId + organizationId
   - 数据归属：属于租户内的特定组织
   - 典型数据：组织配置、组织成员、组织项目
   - 访问权限：组织成员可访问
   - 缓存键示例：`hl8:cache:tenant:t123:org:o456:members`

4. **部门级**（Department）：
   - 隔离标识：tenantId + organizationId + departmentId
   - 数据归属：属于组织内的特定部门
   - 典型数据：部门文档、部门任务、部门预算
   - 访问权限：部门成员可访问
   - 缓存键示例：`hl8:cache:tenant:t123:org:o456:dept:d789:tasks`

5. **用户级**（User）：
   - 隔离标识：userId（可选 tenantId、organizationId、departmentId）
   - 数据归属：属于特定用户的私有数据
   - 典型数据：用户偏好、用户草稿、个人笔记、收藏夹
   - 访问权限：仅用户本人可访问
   - 缓存键示例：`hl8:cache:user:u999:preferences`

**技术实现**：

- 隔离上下文（IsolationContext）贯穿整个请求生命周期
- 数据分为共享数据和非共享数据，支持细粒度的访问控制
- 为上层业务提供透明的多层级隔离能力
- 基于 nestjs-cls 的上下文管理
- **支持平台级上下文**：所有标识符为空，表示访问平台数据

**数据共享控制字段设计** ⭐：

每条业务数据都应包含以下共享控制字段：

```typescript
interface BaseDataModel {
  // 隔离字段（定义数据归属）
  tenantId?: string;
  organizationId?: string;
  departmentId?: string;
  userId?: string;

  // 共享控制字段 ⭐
  isShared: boolean; // 是否共享（默认 false）
  sharingLevel?: DataSharingLevel; // 共享级别
  sharedWith?: string[]; // 精确共享对象列表（可选）
}
```

**设计理由**：

1. ✅ **灵活性**：同一层级的数据可以有不同的共享策略
   - 例如：同样是部门文档，有些仅部门可见，有些组织可见
2. ✅ **动态调整**：可以在运行时改变数据的共享状态
   - 例如：部门公告从部门级改为组织级共享
3. ✅ **精细控制**：通过 `sharedWith` 字段实现精确共享
   - 例如：文档只共享给特定的几个用户或部门
4. ✅ **业务场景**：满足复杂需求
   - 工单上报：租户工单共享到平台客服
   - 最佳实践：部门案例共享到整个租户
   - 跨部门协作：文档共享给其他部门
5. ✅ **未来扩展**：可增加高级功能
   - 时间范围共享（如临时授权）
   - 条件共享（如达到某条件后自动共享）
   - 审批流共享（如需审批后才能共享）

**共享规则**：

| 隔离级别     | 允许的共享级别                 | 典型场景           |
| ------------ | ------------------------------ | ------------------ |
| PLATFORM     | PLATFORM                       | 平台数据只能平台级 |
| TENANT       | PLATFORM, TENANT               | 租户工单共享到平台 |
| ORGANIZATION | PLATFORM, TENANT, ORGANIZATION | 组织案例共享到租户 |
| DEPARTMENT   | 所有级别                       | 部门公告共享到组织 |
| USER         | 所有级别                       | 用户文档共享到部门 |

**事件驱动**：

- 关键操作（如租户上下文创建、缓存失效等）通过事件通知
- 支持异步处理和系统解耦
- 提供事件总线和发布订阅机制

### 横切关注点

**基础设施能力**：

- 日志：结构化日志、性能监控
- 异常处理：统一异常处理机制
- 缓存：Redis 缓存、租户隔离、装饰器
- 配置管理：类型安全配置、多格式支持
- Fastify 适配器：企业级 HTTP 服务能力

**实现方式**：

- 通过装饰器透明注入（如 @Cacheable、@Tenant）
- 通过中间件拦截请求（如 TenantExtractionMiddleware）
- 通过 NestJS 模块化机制集成（如 CachingModule、IsolationModule）

## User Scenarios & Testing _(mandatory)_

### User Story 1 - 应用性能优化 (Priority: P1)

开发者在构建高并发 Web 应用时，需要应用能够快速响应用户请求，减少响应延迟，提升整体用户体验。系统应该提供高性能的 HTTP 服务能力和智能缓存机制，自动优化频繁访问的数据。

**Why this priority**: 性能是 SaaS 平台的核心竞争力，直接影响用户体验和系统可扩展性。这是最基础且最关键的能力。

**Independent Test**: 可以通过压力测试工具（如 Apache Bench 或 k6）测试应用的并发处理能力和响应时间，验证在高负载下的性能表现。

**Acceptance Scenarios**:

1. **Given** 应用部署运行中，**When** 1000 个并发请求同时到达，**Then** 99% 的请求在 100ms 内得到响应
2. **Given** 频繁查询的数据已被缓存，**When** 用户请求该数据，**Then** 响应时间比首次请求减少 80% 以上
3. **Given** 缓存数据已过期，**When** 用户请求该数据，**Then** 系统自动刷新缓存并返回最新数据

---

### User Story 2 - 多层级数据隔离（租户、组织、部门） (Priority: P1)

在 SaaS 平台中，数据隔离不仅需要在租户层面实现，还需要支持更细粒度的组织隔离和部门隔离（行级隔离）。系统将数据分为共享数据和非共享数据两类，在不同层级（平台、租户、组织、部门、用户）实现精细化的访问控制。开发者在编写业务代码时，隔离上下文应该自动识别和管理，无需手动处理复杂的数据过滤逻辑。

**数据隔离层级**：

- **平台级隔离**：平台数据与租户数据隔离
- **租户级隔离**：不同租户的数据完全隔离（最基础）
- **组织级隔离**：同一租户内，不同组织的非共享数据隔离
- **部门级隔离**：同一组织内，不同部门的非共享数据隔离
- **用户级隔离**：用户私有数据仅该用户可访问

**数据分类**：

- **共享数据**：可以在特定层级内被所有下级访问（如租户内所有用户可访问的公告）
- **非共享数据**：仅限特定层级访问，不可跨层级访问（如部门内的财务数据）

**Why this priority**: 多层级数据隔离是企业级 SaaS 平台的核心安全能力，必须在架构层面实现细粒度的数据访问控制，这是企业客户的刚性需求。

**Independent Test**: 可以通过创建多租户、多组织、多部门的测试场景，验证：1) 租户间完全隔离；2) 同一租户内，组织A的非共享数据对组织B不可见；3) 同一组织内，部门A的非共享数据对部门B不可见；4) 共享数据在正确的范围内可访问。

**Acceptance Scenarios**:

**租户级隔离**：

1. **Given** 用户属于租户 A，**When** 用户请求数据列表，**Then** 系统仅返回租户 A 的数据
2. **Given** 用户属于租户 A，**When** 用户尝试访问租户 B 的数据，**Then** 系统拒绝访问并返回权限错误
3. **Given** 请求头包含租户标识，**When** 请求到达应用，**Then** 系统自动提取租户上下文并应用到后续所有操作中

**组织级隔离**：

1. **Given** 用户属于租户A的组织X，**When** 用户请求非共享数据，**Then** 系统仅返回组织X的数据，不返回组织Y的数据
2. **Given** 租户A创建了一条共享数据，**When** 组织X和组织Y的用户分别请求，**Then** 两个组织的用户都能访问该共享数据
3. **Given** 组织X创建了一条非共享数据，**When** 组织Y的用户尝试访问，**Then** 系统拒绝访问并返回权限错误

**部门级隔离**：

1. **Given** 用户属于组织X的部门D1，**When** 用户请求非共享数据，**Then** 系统仅返回部门D1的数据，不返回部门D2的数据
2. **Given** 组织X创建了一条共享数据，**When** 部门D1和部门D2的用户分别请求，**Then** 两个部门的用户都能访问该共享数据
3. **Given** 部门D1创建了一条非共享数据，**When** 部门D2的用户尝试访问，**Then** 系统拒绝访问并返回权限错误

**用户级隔离**：

1. **Given** 用户A创建了一条用户私有数据，**When** 用户B尝试访问，**Then** 系统拒绝访问（即使在同一部门）
2. **Given** 用户A创建了一条标记为部门共享的数据，**When** 同部门的用户B请求，**Then** 用户B可以访问该数据

---

### User Story 3 - 统一错误处理和用户反馈 (Priority: P2)

当应用发生错误时（如输入验证失败、业务规则违反、系统异常等），用户应该收到清晰、一致、友好的错误信息。开发者无需在每个接口中重复编写错误处理逻辑，系统应该自动捕获和转换各类异常。

**Why this priority**: 统一的错误处理提升用户体验和系统可维护性，减少开发者的重复工作，是重要的开发效率和用户体验保障。

**Independent Test**: 可以通过触发各类错误场景（输入验证、业务规则、系统异常），验证错误响应的格式一致性和信息完整性。

**Acceptance Scenarios**:

1. **Given** 用户输入无效数据，**When** 提交表单，**Then** 收到结构化的错误响应，包含字段级别的错误描述
2. **Given** 业务规则验证失败，**When** 执行操作，**Then** 收到业务友好的错误信息，说明失败原因和建议操作
3. **Given** 系统内部发生异常，**When** 用户请求处理失败，**Then** 收到通用错误信息，不暴露敏感的系统细节
4. **Given** 不同类型的错误发生，**When** 返回错误响应，**Then** 所有错误响应遵循相同的数据结构（错误码、消息、详情）

---

### User Story 4 - 结构化日志和问题诊断 (Priority: P2)

运维人员和开发者需要快速定位和诊断生产环境问题。系统应该自动记录所有关键操作、错误和性能指标，日志信息应该结构化、易于搜索和分析。

**Why this priority**: 完善的日志系统是生产环境问题诊断的基础，对系统可观测性和快速故障恢复至关重要。

**Independent Test**: 可以通过执行各类业务操作，检查日志输出的完整性、格式一致性，以及使用日志查询工具验证可搜索性。

**Acceptance Scenarios**:

1. **Given** 用户执行业务操作，**When** 操作完成，**Then** 系统记录操作日志，包含用户标识、租户标识、操作类型、时间戳、耗时
2. **Given** 系统发生错误，**When** 错误被捕获，**Then** 记录完整的错误日志，包含错误堆栈、上下文信息、请求参数
3. **Given** 请求处理耗时超过阈值，**When** 请求完成，**Then** 记录性能警告日志，标记为慢查询
4. **Given** 日志已记录到存储，**When** 运维人员搜索日志，**Then** 可以通过租户ID、用户ID、时间范围、错误级别等条件快速过滤

---

### User Story 5 - 灵活配置管理 (Priority: P3)

开发者需要在不同环境（开发、测试、生产）中使用不同的配置参数（如数据库连接、缓存设置、日志级别等），且配置应该支持环境变量、配置文件等多种来源，便于部署和维护。

**Why this priority**: 配置管理简化了部署流程和环境切换，是开发体验的重要组成部分，但相对于核心业务功能优先级略低。

**Independent Test**: 可以通过修改不同环境的配置文件或环境变量，验证应用能正确读取和应用配置。

**Acceptance Scenarios**:

1. **Given** 配置文件中定义了数据库连接信息，**When** 应用启动，**Then** 成功连接到指定的数据库
2. **Given** 环境变量设置了缓存过期时间，**When** 应用启动，**Then** 使用环境变量的值覆盖默认配置
3. **Given** 生产环境配置文件设置日志级别为 ERROR，**When** 应用运行，**Then** 只记录 ERROR 及以上级别的日志
4. **Given** 配置项缺失且无默认值，**When** 应用启动，**Then** 启动失败并提供清晰的错误信息说明缺失的配置项

---

### Edge Cases

- **缓存一致性问题**: 当数据更新时，如何确保缓存及时失效或更新？系统应该提供缓存失效策略（如 TTL、主动清除）。对于多层级隔离的缓存，需要考虑缓存键的层级标识
- **隔离上下文丢失**: 在异步操作或消息队列处理中，如何传递和保持多层级隔离上下文（租户、组织、部门、用户）？系统应该在消息中自动携带完整的隔离上下文
- **跨层级数据访问**: 当用户同时属于多个组织或部门时（兼职场景），如何确定数据访问范围？系统应该支持上下文切换或合并多个层级的数据访问权限
- **日志洪水**: 当系统发生大量错误时，如何避免日志系统被淹没？应该支持日志采样和限流
- **配置热更新**: 系统支持部分配置的热更新（如日志级别、缓存参数），无需重启应用即可生效。核心配置（如数据库连接）的变更需要重启应用
- **多级缓存**: 系统支持可配置的缓存适配器，允许在不同环境选择不同的缓存实现（内存缓存或分布式缓存）。缓存键需要包含完整的隔离层级信息
- **隔离上下文识别机制**: 系统从请求头中获取多层级标识（X-Tenant-Id、X-Organization-Id、X-Department-Id、X-User-Id），自动构建完整的隔离上下文
- **共享数据范围判断**: 当数据标记为共享时，如何确定共享范围（租户内共享、组织内共享、部门内共享）？系统应该提供清晰的共享级别定义
- **行级安全策略性能**: 多层级行级隔离可能影响查询性能，如何优化？系统应该支持索引优化和查询计划缓存
- **数据迁移场景**: 当组织结构调整时（如部门合并、用户调岗），如何处理数据的隔离归属？系统应该提供数据重新归属的机制

## Requirements _(mandatory)_

### Functional Requirements

#### 性能要求

- **FR-001**: 系统必须提供高性能的 HTTP 服务能力，支持至少 1000 并发连接
- **FR-002**: 系统必须提供缓存机制，支持数据的自动缓存和失效管理
- **FR-012**: 系统必须在高并发场景下保持稳定，不出现请求丢失或处理阻塞

#### 多层级数据隔离要求

- **FR-003**: 系统必须支持多租户数据隔离，确保租户间数据完全隔离，不可跨访问
- **FR-004**: 系统必须支持组织级数据隔离，确保同一租户内不同组织的非共享数据相互隔离
- **FR-005**: 系统必须支持部门级数据隔离，确保同一组织内不同部门的非共享数据相互隔离
- **FR-006**: 系统必须支持用户级数据隔离，确保用户私有数据仅该用户可访问
- **FR-007**: 系统必须支持数据共享机制，区分共享数据和非共享数据
- **FR-008**: 系统必须支持定义数据的共享级别（租户共享、组织共享、部门共享、用户私有）
- **FR-009**: 系统必须自动识别和管理多层级隔离上下文（租户、组织、部门、用户），开发者无需手动处理
- **FR-010**: 系统必须从请求头中提取多层级标识（X-Tenant-Id、X-Organization-Id、X-Department-Id、X-User-Id）
- **FR-011**: 系统必须在缺少必需的隔离标识时返回明确的错误响应
- **FR-012a**: 系统必须支持用户在多个组织或部门时的上下文切换
- **FR-012b**: 系统必须在缓存键中包含完整的隔离层级信息，确保缓存数据的隔离性

#### 异常处理要求

- **FR-013**: 系统必须捕获所有未处理的异常，并转换为统一格式的错误响应
- **FR-014**: 系统必须提供结构化的错误响应格式，包含错误码、错误消息、错误详情

#### 日志要求

- **FR-015**: 系统必须记录所有关键操作的结构化日志，包含时间戳、完整的隔离上下文（租户、组织、部门、用户）、操作类型
- **FR-016**: 系统必须记录所有错误和异常的详细日志，包含错误堆栈和上下文信息
- **FR-017**: 系统必须支持不同日志级别（DEBUG、INFO、WARN、ERROR），可通过配置调整

#### 配置管理要求

- **FR-018**: 系统必须支持通过配置文件和环境变量管理应用配置
- **FR-019**: 系统必须在启动时验证必需的配置项，缺失时提供清晰的错误提示
- **FR-020**: 系统必须支持部分配置的热更新（日志级别、缓存参数等），无需重启应用
- **FR-021**: 系统必须支持可配置的缓存适配器，允许在不同环境使用不同的缓存实现

### Key Entities（领域实体）

基于宪章定义的统一语言，本模块涉及以下核心实体：

#### 平台级实体

- **隔离上下文 (IsolationContext)**:
  - **定义**: 多层级数据隔离的核心实体，包含完整的隔离层级信息
  - **属性**:
    - 平台ID（platformId）
    - 租户ID（tenantId）
    - 租户类型（企业/社群/团队/个人）
    - 组织ID列表（organizationIds，支持用户同时属于多个组织）
    - 部门ID列表（departmentIds，支持用户同时属于多个部门）
    - 当前激活的组织ID（activeOrganizationId）
    - 当前激活的部门ID（activeDepartmentId）
    - 用户ID（userId）
  - **生命周期**: 在HTTP请求到达时创建，在请求处理完成后销毁
  - **作用范围**: 贯穿整个请求处理链路，所有业务逻辑可访问
  - **与宪章的对应**: 整合了 Platform、Tenant、Organization、Department、User 的完整层级关系

- **租户上下文 (TenantContext)**:
  - **定义**: 标识当前请求所属的租户（Tenant），是租户级隔离的核心实体
  - **属性**: 租户ID（tenantId）、租户类型（企业/社群/团队/个人）、租户名称、租户状态
  - **生命周期**: 在HTTP请求到达时创建，在请求处理完成后销毁
  - **作用范围**: 贯穿整个请求处理链路，所有业务逻辑可访问
  - **与宪章的对应**: 对应 `docs/definition-of-terms.mdc` 中的 Tenant 概念
  - **关系**: 是 IsolationContext 的一部分

- **组织上下文 (OrganizationContext)**:
  - **定义**: 标识当前请求所属的组织（Organization），用于组织级数据隔离
  - **属性**: 组织ID（organizationId）、组织名称、组织类型（委员会/项目团队/质量小组等）
  - **生命周期**: 从 IsolationContext 中提取，在请求处理中可访问
  - **作用范围**: 用于过滤组织级非共享数据
  - **与宪章的对应**: 对应 `docs/definition-of-terms.mdc` 中的 Organization 概念
  - **关系**: 是 IsolationContext 的一部分

- **部门上下文 (DepartmentContext)**:
  - **定义**: 标识当前请求所属的部门（Department），用于部门级数据隔离
  - **属性**: 部门ID（departmentId）、部门名称、部门层级、上级部门ID
  - **生命周期**: 从 IsolationContext 中提取，在请求处理中可访问
  - **作用范围**: 用于过滤部门级非共享数据
  - **与宪章的对应**: 对应 `docs/definition-of-terms.mdc` 中的 Department 概念
  - **关系**: 是 IsolationContext 的一部分

- **用户上下文 (UserContext)**:
  - **定义**: 标识当前请求所属的用户（User），用于权限控制和审计追踪
  - **属性**: 用户ID（userId）、用户名称、用户角色、用户归属（平台/租户/组织/部门）
  - **生命周期**: 在认证成功后创建，在请求处理完成后销毁
  - **作用范围**: 与 IsolationContext 配合使用，确保用户在正确的隔离上下文中操作
  - **与宪章的对应**: 对应 `docs/definition-of-terms.mdc` 中的 User 概念
  - **关系**: 是 IsolationContext 的一部分

- **数据共享策略 (DataSharingPolicy)**:
  - **定义**: 定义数据的共享级别和访问范围
  - **属性**:
    - 共享级别（sharingLevel）: PLATFORM（平台共享）、TENANT（租户共享）、ORGANIZATION（组织共享）、DEPARTMENT（部门共享）、USER（用户私有）
    - 所有者类型（ownerType）: PLATFORM、TENANT、ORGANIZATION、DEPARTMENT、USER
    - 所有者ID（ownerId）
    - 是否共享（isShared）: true（共享数据）/ false（非共享数据）
  - **生命周期**: 数据创建时定义，可以在数据生命周期内更新
  - **作用范围**: 用于判断数据的可访问范围
  - **业务规则**:
    - 非共享数据只能在所有者层级访问
    - 共享数据可以在共享级别及其下级层级访问
    - 上级层级的共享数据对下级可见（如租户共享数据对所有组织和部门可见）

#### 基础设施实体

- **缓存条目 (CacheEntry)**:
  - **定义**: 缓存的数据项，支持多层级数据隔离
  - **属性**:
    - 缓存键（key）
    - 缓存值（value）
    - 过期时间（TTL）
    - 隔离层级信息（isolationInfo）:
      - 租户标识（tenantId）
      - 组织标识（organizationId，可选）
      - 部门标识（departmentId，可选）
      - 用户标识（userId，可选）
    - 创建时间
  - **隔离策略**: 缓存键自动添加完整的层级前缀（如：`tenant:123:org:456:dept:789:key`），确保不同层级的缓存数据完全隔离
  - **失效策略**: 支持基于时间的自动失效（TTL）和主动清除
  - **性能优化**: 支持基于隔离层级的批量失效（如清除整个租户的缓存）

- **错误响应 (ErrorResponse)**:
  - **定义**: 统一的错误响应结构，确保所有错误以一致的格式返回给客户端
  - **属性**: 错误码（errorCode）、错误消息（message）、错误详情（details）、时间戳（timestamp）、请求ID（requestId）、租户ID（tenantId）
  - **国际化**: 初始版本支持中文，遵循宪章的中文优先原则
  - **安全性**: 生产环境不暴露敏感的系统内部错误详情

- **日志条目 (LogEntry)**:
  - **定义**: 结构化的日志记录，支持快速检索和问题诊断
  - **属性**:
    - 日志级别（level）
    - 时间戳（timestamp）
    - 完整的隔离上下文（isolationContext）:
      - 租户ID（tenantId）
      - 组织ID（organizationId，可选）
      - 部门ID（departmentId，可选）
      - 用户ID（userId）
    - 消息内容（message）
    - 上下文数据（context）
    - 请求ID（requestId）
  - **结构化**: 采用 JSON 格式，便于日志聚合和分析工具处理
  - **关联性**: 通过 requestId 关联同一请求的所有日志条目
  - **可追溯性**: 包含完整的隔离层级信息，便于追踪数据访问路径

- **配置项 (ConfigurationItem)**:
  - **定义**: 应用配置参数，支持多环境和多来源的配置管理
  - **属性**: 配置键（key）、配置值（value）、数据类型（type）、默认值（defaultValue）、是否必需（required）、环境（environment）
  - **优先级**: 环境变量 > 配置文件 > 默认值
  - **热更新**: 部分配置项支持运行时更新，无需重启应用

#### 领域事件

为支持事件驱动架构（EDA），本模块定义以下领域事件：

**隔离上下文事件**：

- **IsolationContextCreatedEvent**: 隔离上下文创建事件，当请求到达并成功构建完整的多层级隔离上下文时触发
  - 包含：完整的隔离层级信息（Platform、Tenant、Organization、Department、User）
  - 用途：审计追踪、上下文传播、安全监控

- **IsolationContextSwitchedEvent**: 隔离上下文切换事件，当用户切换组织或部门时触发
  - 包含：切换前后的上下文信息、切换原因、切换时间
  - 用途：用户行为分析、异常检测

- **TenantContextCreatedEvent**: 租户上下文创建事件，当请求到达并成功识别租户时触发（向后兼容）
  - 包含：租户ID、租户类型、租户名称
  - 用途：租户级监控、审计

**数据访问事件**：

- **DataAccessDeniedEvent**: 数据访问被拒绝事件，当用户尝试访问无权限的数据时触发
  - 包含：用户信息、目标数据的隔离层级、拒绝原因
  - 用途：安全审计、异常行为检测

- **CrossLevelDataAccessEvent**: 跨层级数据访问事件，当发生跨层级数据访问时触发（如访问上级共享数据）
  - 包含：访问者层级、数据所有者层级、数据共享策略
  - 用途：数据访问审计、权限合规性检查

**缓存事件**：

- **CacheInvalidatedEvent**: 缓存失效事件，当缓存数据被清除时触发
  - 包含：缓存键、隔离层级信息、失效原因（TTL过期/主动清除/层级清除）
  - 用途：缓存性能分析、调试

- **CacheLevelInvalidatedEvent**: 缓存层级失效事件，当清除整个层级的缓存时触发
  - 包含：失效的层级类型（TENANT/ORGANIZATION/DEPARTMENT）、层级ID
  - 用途：批量缓存管理、性能监控

**系统事件**：

- **ErrorOccurredEvent**: 错误发生事件，当系统捕获到异常时触发
  - 包含：错误信息、完整的隔离上下文、错误堆栈
  - 用途：错误追踪、问题诊断

- **PerformanceWarningEvent**: 性能警告事件，当请求处理耗时超过阈值时触发
  - 包含：请求信息、隔离上下文、耗时、慢查询SQL（如有）
  - 用途：性能优化、慢查询分析

## Success Criteria _(mandatory)_

### Measurable Outcomes

**性能指标**：

- **SC-001**: 应用能够处理至少 1000 个并发请求，99% 的请求响应时间在 100ms 以内
- **SC-002**: 缓存命中的请求响应时间比未缓存的请求减少 80% 以上
- **SC-009**: 多层级数据隔离对查询性能的影响控制在 15% 以内（相比无隔离的查询）

**安全隔离指标**：

- **SC-003**: 多租户数据隔离通过安全审计，无跨租户数据泄露风险，隔离有效性达到 100%
- **SC-010**: 组织级数据隔离通过安全测试，同一租户内不同组织的非共享数据完全隔离，隔离有效性达到 100%
- **SC-011**: 部门级数据隔离通过安全测试，同一组织内不同部门的非共享数据完全隔离，隔离有效性达到 100%
- **SC-012**: 用户级数据隔离通过安全测试，用户私有数据访问控制准确率达到 100%
- **SC-013**: 共享数据的访问范围判断准确率达到 100%，无误授权或误拒绝情况
- **SC-014**: 跨层级数据访问事件100%被记录并可追溯

**系统质量指标**：

- **SC-004**: 所有类型的错误都能返回统一格式的错误响应，格式一致性达到 100%
- **SC-005**: 关键业务操作的日志记录覆盖率达到 100%，所有日志都包含完整的隔离上下文信息
- **SC-006**: 生产环境问题诊断时间减少 50%，通过日志能够快速定位问题根因和数据访问路径
- **SC-007**: 应用在不同环境中的部署配置时间减少 70%，配置错误导致的启动失败能立即被发现

**开发效率指标**：

- **SC-008**: 开发者在编写业务代码时，无需手动处理多层级隔离、异常转换、日志记录等横切关注点，代码简洁度提升 40%
- **SC-015**: 数据隔离相关的代码重复度降低 80%，通过统一的隔离机制实现

## 质量保证要求

根据项目宪章的质量保证原则和测试架构原则：

### 代码质量

- **中文优先**: 所有代码注释、错误消息、日志信息必须使用中文
- **TSDoc 规范**: 所有公共 API、类、方法、接口必须添加完整的 TSDoc 注释
- **代码即文档**: 注释必须包含业务规则、使用场景、注意事项、示例代码
- **ESLint 配置**: 必须继承 monorepo 根目录的 ESLint 配置
- **TypeScript 配置**: 必须继承 monorepo 根 tsconfig.json

### 测试要求

- **单元测试**:
  - 测试文件与源代码同目录，命名为 `{文件名}.spec.ts`
  - 核心业务逻辑测试覆盖率 ≥ 80%
  - 所有公共 API 必须有对应的测试用例

- **集成测试**:
  - 放置在 `__tests__/integration/` 目录
  - 测试多租户隔离、缓存机制、错误处理等集成场景
  - 关键路径测试覆盖率 ≥ 90%

- **端到端测试**:
  - 放置在 `__tests__/e2e/` 目录
  - 测试完整的请求处理流程（从 HTTP 请求到响应）

- **测试独立性**:
  - 测试之间相互独立，不依赖执行顺序
  - 使用 beforeEach/afterEach 清理状态
  - 避免共享可变状态

### 文档要求

- **README.md**: 提供模块概述、安装说明、快速开始、API 文档
- **架构文档**: 说明模块的架构设计、核心概念、设计决策
- **使用示例**: 提供多租户集成、缓存使用、错误处理等典型场景的示例代码
- **迁移指南**: 如果有破坏性变更，提供详细的迁移指南

## 技术约束

根据项目宪章的技术约束：

### 技术栈

- **运行环境**: Node.js >= 20
- **开发语言**: TypeScript 5.9.2
- **包管理器**: pnpm 10.11.0（必须）
- **后端框架**: NestJS >= 11
- **HTTP 服务器**: Fastify（高性能）
- **日志库**: Pino（高性能结构化日志）
- **测试框架**: Jest + Supertest

### TypeScript 配置（宪章要求）

必须遵循宪章的 TypeScript 配置要求：

- **模块系统**: NodeNext（必须）
- **模块解析**: NodeNext（必须）
- **目标版本**: ES2022
- **严格模式**: 启用（strict: true）
- **模块检测**: 强制（moduleDetection: force）
- **ES 模块互操作**: 启用（esModuleInterop: true）

**tsconfig.json**:

```json
{
  "extends": "@repo/typescript-config/nestjs.json",
  "compilerOptions": {
    "outDir": "./dist",
    "baseUrl": "./",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```

**package.json**:

```json
{
  "type": "module",
  "engines": {
    "node": ">=20"
  }
}
```

### 编译工具（宪章要求）

必须联合使用 tsc 和 swc：

- **TypeScript (tsc)**: 类型检查和生成类型声明
- **SWC**: 快速编译（比 tsc 快 20-70 倍）

**构建脚本**:

```json
{
  "scripts": {
    "build": "pnpm clean && pnpm build:swc && pnpm build:types",
    "build:swc": "swc src -d dist --config-file ../../.swcrc",
    "build:types": "tsc --project tsconfig.build.json --declaration --emitDeclarationOnly --outDir dist",
    "type-check": "tsc --noEmit",
    "dev": "swc src -d dist --watch --config-file ../../.swcrc"
  }
}
```

### 配置管理

- **配置继承**: 必须继承 monorepo 根配置
- **配置位置**:
  - 根目录：全局配置（ESLint、TypeScript、Prettier）
  - 本项目：扩展并定制根配置
- **避免碎片化**: 仅在必要时添加项目特定配置

### 性能和可扩展性

- **水平扩展**: 模块设计必须支持水平扩展（无状态设计）
- **缓存策略**: 合理使用缓存提升性能，支持多种缓存适配器
- **异步处理**: 支持通过消息队列实现异步处理和解耦

### 依赖管理

- **依赖最小化**: 只引入必需的依赖，避免依赖膨胀
- **版本锁定**: 使用 pnpm-lock.yaml 锁定依赖版本
- **安全审计**: 定期运行 `pnpm audit` 检查安全漏洞

## 宪章合规性检查

本规范遵循项目宪章（`.specify/memory/constitution.md` v1.5.0）的所有核心原则：

### ✅ 中文优先原则

- 所有代码注释、错误消息、日志信息使用中文
- 技术文档使用中文编写
- API 文档和接口说明使用中文

### ✅ 代码即文档原则

- 所有公共 API 添加完整的 TSDoc 注释
- 注释包含业务规则、使用场景、示例代码
- 代码变更时同步更新注释

### ✅ 架构原则

- 遵循 Clean Architecture + DDD + CQRS + ES + EDA 混合架构模式
- 四层架构：领域层、应用层、基础设施层、接口层
- DDD 充血模型：IsolationContext 等领域对象封装业务逻辑，禁止贫血模型
- 领域实体和聚合根概念明确（虽然本模块主要是基础设施）
- 用例明确：提供上下文创建、数据隔离等基础设施能力
- 核心业务逻辑（多层级隔离规则）独立于框架
- CQRS 支持：隔离上下文创建（Command）和查询（Query）分离
- 事件溯源支持：提供事件存储基础设施
- 事件驱动架构：定义并发布领域事件（IsolationContextCreatedEvent 等）
- 基础设施关注点与业务逻辑分离
- 依赖关系从外向内

### ✅ Monorepo 组织原则

- 项目位置：`libs/nestjs-enhance`（服务端基础设施库）
- 使用 pnpm 作为包管理工具
- 为平台内所有服务端应用提供共享能力

### ✅ 质量保证原则

- ESLint 配置继承根目录配置
- TypeScript 配置继承 monorepo 根 tsconfig.json
- 使用 MCP 工具进行代码检查

### ✅ 测试架构原则

- 单元测试文件与被测试文件在同一目录（.spec.ts）
- 集成测试放置在 `__tests__/integration/` 目录
- 端到端测试放置在 `__tests__/e2e/` 目录
- 核心业务逻辑测试覆盖率 ≥ 80%
- 所有公共 API 必须有对应的测试用例

### ✅ 统一语言原则（Ubiquitous Language）

- 使用宪章定义的统一术语（Tenant、User、Platform）
- 核心业务实体命名符合术语定义
- TenantContext 和 UserContext 对应宪章中的领域模型
- 支持宪章定义的四种租户类型（企业/社群/团队/个人）
- 技术实现能够追溯到业务术语和领域模型

## Assumptions

1. **部署环境**: 假设应用部署在支持环境变量注入的现代化部署环境中（如 Kubernetes、Docker）

2. **租户规模**:
   - 假设平台支持最多 10000 个租户（Tenant）
   - 单个租户的并发用户数在 100 以内
   - 支持企业租户、社群租户、团队租户、个人租户四种类型

3. **组织结构规模**:
   - 假设单个租户最多支持 100 个组织（Organization）
   - 假设单个组织最多支持 8 层部门嵌套
   - 假设单个部门最多支持 500 个直属成员

4. **用户兼职场景**:
   - 假设用户最多同时属于 5 个不同的组织
   - 假设用户在同一组织内最多同时属于 3 个不同的部门
   - 假设默认使用用户的主组织和主部门作为当前激活的上下文

5. **数据共享策略**:
   - 假设 80% 的数据为非共享数据，需要严格的层级隔离
   - 假设 20% 的数据为共享数据，需要明确的共享范围定义
   - 假设数据的共享级别在创建时确定，后续可通过权限管理修改

6. **缓存策略**:
   - 假设默认使用基于时间的缓存失效策略（TTL），过期时间可配置
   - 假设多层级隔离的缓存键长度增加不超过 100 字符
   - 假设缓存层级失效时，采用前缀匹配方式批量删除

7. **日志存储**: 假设日志输出到标准输出流（stdout/stderr），由外部日志收集系统（如 ELK、Loki）负责收集、存储和分析

8. **错误信息国际化**: 假设初始版本仅支持中文错误信息（遵循中文优先原则），后续可扩展多语言支持

9. **性能基准**: 假设性能测试基于标准的 Web 服务器硬件配置（4核CPU、8GB内存）

10. **缓存适配器**:
    - 开发环境：使用内存缓存（cache-manager）
    - 生产环境：可选择分布式缓存方案（Redis、Memcached）

11. **配置热更新范围**: 假设运行时可调整的配置项不超过总配置项的 30%，多为调优参数（如日志级别、缓存TTL）

12. **认证集成**: 假设认证功能由独立的认证服务提供，认证服务会返回完整的隔离上下文信息（租户、组织、部门、用户）

13. **监控集成**: 假设监控和指标收集由外部系统（如 Prometheus）负责，本模块提供标准的指标接口

14. **数据库支持**: 假设底层数据库支持行级安全策略（Row-Level Security），如 PostgreSQL RLS 或等效机制

15. **性能优化**: 假设数据库层面会为隔离字段（tenantId、organizationId、departmentId）创建合适的索引以优化查询性能
