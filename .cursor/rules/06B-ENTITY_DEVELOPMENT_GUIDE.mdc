---
description: 实体开发规范
globs:
alwaysApply: true
---
# 实体开发规范（Entity Development Guide）

## 概述

本文档阐述在 `libs/business-core` 中开发领域实体的规范，包括实体设计原则、继承关系、业务逻辑封装和与隔离模型的协作方式。

## 设计原则

### 1. 充血模型设计

- **充血模型**：实体包含业务逻辑，而非贫血模型（只有数据）
- **业务规则封装**：所有业务规则都在实体内部实现
- **状态变更控制**：通过业务方法控制状态变更，确保业务规则执行

### 2. 实体与聚合根分离

- **实体（Entity）**：业务数据记录，包含业务逻辑
- **聚合根（Aggregate Root）**：管理实体生命周期，协调业务操作
- **分离原则**：实体专注业务逻辑，聚合根专注业务协调

### 3. 继承关系

```typescript
// ✅ 正确：业务实体继承 BaseEntity
class Tenant extends BaseEntity { ... }
class User extends BaseEntity { ... }

// ❌ 错误：不要继承 IsolationContext
class Tenant extends IsolationContext { ... }
```

### 4. 标识符使用

- **业务实体ID**：使用 `@hl8/isolation-model` 的专用ID类型
- **隔离查询**：使用 `IsolationContext` 进行数据过滤

## 实体开发规范

### 1. 基础结构

```typescript
import { BaseEntity } from '../base/base-entity.js';
import { EntityId, TenantId } from '@hl8/isolation-model';
import type { IPureLogger } from '@hl8/pure-logger';
import type { IPartialAuditInfo } from '../base/audit-info.js';

export class Tenant extends BaseEntity {
  private _name: string;
  private _type: TenantType;

  constructor(
    id: EntityId,
    props: { name: string; type: TenantType },
    audit: IPartialAuditInfo,
    logger?: IPureLogger,
  ) {
    super(id, audit, logger);
    this._name = props.name;
    this._type = props.type;
    this.validate();
  }
}
```

### 2. 属性设计

- **私有属性**：使用 `private _property` 命名
- **只读访问器**：提供 `get property()` 方法
- **业务方法**：封装状态变更逻辑

```typescript
// 属性定义
private _name: string;
private _status: TenantStatus;

// 只读访问器
get name(): string {
  return this._name;
}

get status(): TenantStatus {
  return this._status;
}

// 业务方法
rename(newName: string): void {
  this.validateName(newName);
  this._name = newName.trim();
  this.updateTimestamp();
  this.logOperation('rename', { name: this._name });
}
```

### 3. 业务规则封装

- **验证逻辑**：在 `validate()` 方法中实现
- **业务约束**：在业务方法中检查
- **状态转换**：通过业务方法控制

```typescript
protected override validate(): void {
  super.validate();
  this.validateName(this._name);
  this.validateType(this._type);
}

private validateName(name: string): void {
  if (!name || !name.trim()) {
    throw new Error('租户名称不能为空');
  }
  if (name.trim().length > 100) {
    throw new Error('租户名称长度不能超过100');
  }
}
```

### 4. 与隔离模型的协作

```typescript
// 实体定义时使用隔离模型的ID类型
import { EntityId, TenantId, OrganizationId } from '@hl8/isolation-model';

export class Tenant extends BaseEntity {
  constructor(
    id: EntityId, // 使用隔离模型的EntityId
    props: { name: string; type: TenantType },
    audit: IPartialAuditInfo,
    logger?: IPureLogger,
  ) {
    super(id, audit, logger);
    // ...
  }
}

// 查询时使用隔离上下文
const context = IsolationContext.tenant(tenantId);
const tenants = await tenantRepository.findByContext(context);
```

## 目录结构

```
libs/business-core/src/domain/entities/
├── base/                    # 基础实体类
│   ├── base-entity.ts       # 基础实体抽象类
│   ├── audit-info.ts        # 审计信息接口
│   └── entity.interface.ts  # 实体接口
├── tenant/                  # 租户实体
│   ├── tenant.entity.ts    # 租户实体实现
│   └── index.ts            # 导出文件
├── user/                    # 用户实体
│   ├── user.entity.ts      # 用户实体实现
│   └── index.ts            # 导出文件
└── index.ts                # 统一导出
```

## 命名规范

### 1. 文件命名
- 实体文件：`{entity-name}.entity.ts`
- 目录名：`{entity-name}/`
- 导出文件：`index.ts`

### 2. 类命名
- 实体类：`PascalCase`，如 `Tenant`、`User`
- 属性：`private _camelCase`
- 方法：`camelCase`

### 3. 方法命名
- 业务操作：动词形式，如 `rename()`、`activate()`
- 状态查询：`is*()` 形式，如 `isActive()`
- 验证方法：`validate*()` 形式

## 充血模型设计

### 1. 业务逻辑封装

实体必须包含完整的业务逻辑，避免贫血模型：

```typescript
export class Tenant extends BaseEntity {
  private _status: TenantStatus;
  private _quota: TenantQuota;

  // ✅ 充血模型：业务逻辑在实体内部
  activate(): void {
    this.validateActivation();
    this._status = TenantStatus.ACTIVE;
    this.updateTimestamp();
    this.logOperation('activate');
  }

  // ✅ 业务规则封装在实体内部
  private validateActivation(): void {
    if (this._status === TenantStatus.ACTIVE) {
      throw new Error('租户已激活');
    }
    if (!this._quota.isValid()) {
      throw new Error('租户配额无效，无法激活');
    }
  }

  // ✅ 业务方法控制状态变更
  deactivate(): void {
    if (this._status === TenantStatus.INACTIVE) {
      throw new Error('租户已停用');
    }
    this._status = TenantStatus.INACTIVE;
    this.updateTimestamp();
    this.logOperation('deactivate');
  }
}
```

### 2. 实体与聚合根分离

```typescript
// 实体：专注业务逻辑
export class Tenant extends BaseEntity {
  private _name: string;
  private _type: TenantType;

  rename(newName: string): void {
    this.validateName(newName);
    this._name = newName;
    this.updateTimestamp();
  }

  changeType(newType: TenantType): void {
    this.validateTypeChange(newType);
    this._type = newType;
    this.updateTimestamp();
  }
}

// 聚合根：管理实体生命周期，协调业务操作
export class TenantAggregate {
  private tenant: Tenant;
  private events: DomainEvent[] = [];

  renameTenant(newName: string): void {
    this.tenant.rename(newName);
    this.events.push(new TenantRenamedEvent(this.tenant.id, newName));
  }

  changeTenantType(newType: TenantType): void {
    this.tenant.changeType(newType);
    this.events.push(new TenantTypeChangedEvent(this.tenant.id, newType));
  }

  getUncommittedEvents(): DomainEvent[] {
    return [...this.events];
  }
}
```

### 3. 业务规则验证

```typescript
export class Tenant extends BaseEntity {
  changeType(newType: TenantType): void {
    this.validateTypeChange(this._type, newType);
    this._type = newType;
    this.updateTimestamp();
    this.logOperation('changeType', { type: newType.value });
  }

  private validateTypeChange(oldType: TenantType, newType: TenantType): void {
    // 业务规则：企业租户不能降级为个人租户
    if (oldType.isEnterprise() && newType.isPersonal()) {
      throw new Error('企业租户不能降级为个人租户');
    }
  }
}
```

## 测试要求

### 1. 单元测试覆盖
- 实体创建和验证
- 业务方法执行
- 状态转换逻辑
- 异常情况处理

### 2. 测试示例

```typescript
describe('Tenant', () => {
  it('should create tenant with valid data', () => {
    const tenant = new Tenant(
      EntityId.generate(),
      { name: 'Test Tenant', type: TenantType.ENTERPRISE },
      { createdBy: 'system' }
    );
    
    expect(tenant.name).toBe('Test Tenant');
    expect(tenant.type).toBe(TenantType.ENTERPRISE);
  });

  it('should throw error when renaming with invalid name', () => {
    const tenant = new Tenant(/* ... */);
    
    expect(() => tenant.rename('')).toThrow('租户名称不能为空');
  });
});
```

## 最佳实践

### 1. 实体设计
- 保持实体纯净，不依赖基础设施
- 业务逻辑封装在实体内部
- 使用值对象表达复杂概念

### 2. 与聚合根的关系
- **实体职责**：专注业务逻辑和状态管理
- **聚合根职责**：管理实体生命周期，协调业务操作，发布领域事件
- **分离原则**：实体不直接发布事件，通过聚合根协调

### 3. 性能考虑
- 避免在实体中执行重量级操作
- 使用懒加载处理复杂关联
- 合理使用缓存减少重复计算

## 反模式清单

### ❌ 禁止的做法

1. **继承隔离上下文**
```typescript
// 错误
class Tenant extends IsolationContext { ... }
```

2. **在实体中直接操作数据库**
```typescript
// 错误
class Tenant extends BaseEntity {
  async save() {
    await this.repository.save(this); // 不要在实体中直接操作仓储
  }
}
```

3. **暴露可变属性**
```typescript
// 错误
class Tenant extends BaseEntity {
  public name: string; // 应该使用私有属性和业务方法
}
```

4. **在实体中处理外部依赖**
```typescript
// 错误
class Tenant extends BaseEntity {
  sendEmail() {
    this.emailService.send(/* ... */); // 不要在实体中处理外部服务
  }
}
```

5. **贫血模型设计**
```typescript
// 错误：只有数据，没有业务逻辑
class Tenant extends BaseEntity {
  public name: string;
  public type: TenantType;
  // 缺少业务方法
}
```

### ✅ 推荐的做法

1. **使用业务方法封装状态变更**
```typescript
class Tenant extends BaseEntity {
  rename(newName: string): void {
    this.validateName(newName);
    this._name = newName;
    this.updateTimestamp();
  }
}
```

2. **通过聚合根处理复杂业务逻辑**
```typescript
class TenantAggregate {
  private tenant: Tenant;
  
  renameTenant(newName: string): void {
    this.tenant.rename(newName);
    this.publishEvent(new TenantRenamedEvent(this.tenant.id, newName));
  }
}
```

## 总结

实体开发应遵循DDD原则和充血模型设计：

1. **充血模型**：实体包含完整业务逻辑，避免贫血模型
2. **职责分离**：实体专注业务逻辑，聚合根专注业务协调
3. **继承关系**：继承`BaseEntity`，使用`@hl8/isolation-model`的ID类型
4. **业务封装**：通过业务方法封装状态变更，确保业务规则执行
5. **隔离协作**：通过`IsolationContext`进行查询时的数据过滤，而不是继承关系

遵循这些原则可以确保实体设计符合DDD最佳实践，实现高内聚、低耦合的领域模型。

