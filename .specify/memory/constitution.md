<!--

# SYNC IMPACT REPORT

Version Change: 1.4.0 → 1.5.0
Rationale: 扩展架构原则，正式将 DDD（领域驱动设计）纳入混合架构模式，详细定义 DDD 战术设计和统一语言要求；同时扩展技术约束部分，添加 TypeScript 配置要求和编译工具要求

Modified Sections:

- EXPANDED: III. 架构原则 - 增加 DDD 领域驱动设计详细说明
- EXPANDED: 技术约束 > TypeScript 配置要求（服务端项目）
- NEW: 技术约束 > 编译工具要求（服务端项目）

Added Sections:

- DDD 充血模型（Rich Domain Model）要求（6个核心要求，禁止贫血模型）
- DDD 战术设计（实体、聚合根、值对象、领域服务、仓储、规格模式、领域事件）
- DDD 统一语言（技术实现使用业务术语、代码结构反映业务模型）
- CQRS 详细说明（总线、投影器、读写模型分离）
- 事件溯源详细说明（事件存储、快照、重放、审计追踪）
- 事件驱动详细说明（领域事件、集成事件、事件总线、Saga 模式）
- TypeScript 核心配置（module: NodeNext、moduleResolution: NodeNext 等8个必需配置项）
- 必需配置项说明（详细解释每个配置项的作用和理由）
- package.json 对应配置（type: module、engines）
- 配置继承要求（继承共享配置、禁止覆盖核心配置）
- 禁止使用 CommonJS（明确禁止过时的模块系统）
- 文件扩展名规范（.ts、.mjs、.d.ts）
- 导入导出规范（ES 模块语法）
- 编译策略（tsc 用于类型检查、swc 用于快速编译）
- 构建脚本规范（build、build:swc、dev、type-check）
- CI/CD 流程要求（独立的类型检查步骤）
- 配置文件要求（tsconfig.json、tsconfig.build.json）
- 性能对比和最佳实践

Templates Requiring Updates:
✅ plan-template.md - Constitution Check 已有架构原则和 TypeScript 配置检查项
⚠️ spec-template.md - 需要在技术约束中明确 DDD + NodeNext 配置要求
⚠️ tasks-template.md - 需要在项目初始化任务中包含 DDD 目录结构和配置检查
✅ packages/eslint-config/* - 已完成配置整合和宪章合规性修复
✅ docs/backend-project-template.md - 已完整体现混合架构的目录结构

Follow-up TODOs:

- ✅ ESLint 配置完成：整合到 @repo/eslint-config 共享包
- ✅ 修复 nest.js 配置违反宪章的问题
- ✅ 移除遗留代码配置
- ✅ 修复 packages/ts-config/nestjs.json 违反宪章的问题（CommonJS → NodeNext）
- ✅ 创建根目录 tsconfig.json 全局基础配置
- ✅ 更新所有服务端项目的 package.json（type: module、engines）
- ✅ 创建 packages/ts-config/README.md 配置使用文档
- ✅ 创建 docs/backend-project-template.md 完整的混合架构目录结构
- ✅ 在架构原则中增加充血模型要求
- ⚠️ 运行 `pnpm install` 安装新添加的依赖
- ⚠️ 验证所有服务端项目的构建脚本符合 tsc + swc 规范
- ⚠️ 更新 CI/CD 流程添加独立的类型检查步骤
- ⚠️ 审查现有代码库，确保领域对象使用充血模型而非贫血模型
- ⚠️ 审查现有代码库中的 `any` 使用情况
- ⚠️ 在代码审查检查清单中添加充血模型、TypeScript 配置和 `any` 使用审查项
- ⚠️ 为团队提供 DDD 充血模型培训
- 文档来源：docs/ts-config.md、docs/any-except.md、docs/backend-project-template.md

# Date: 2025-10-11

-->

# HL8 SAAS Platform Constitution

## 核心原则

### I. 中文优先原则 (NON-NEGOTIABLE)

**所有代码注释、文档、错误消息和用户界面必须使用中文。**

这是项目的非协商性要求，确保中国开发团队的理解和协作效率。

- 代码注释必须使用中文，遵循 TSDoc 规范
- 技术文档必须使用中文编写
- 用户界面文本必须使用中文
- 错误消息和日志必须使用中文
- API 文档和接口说明必须使用中文
- Git 提交消息推荐使用中文
- 代码变量命名使用英文，但必须有中文注释说明

**理由**：本项目面向中国大陆地区的企业级SAAS平台，中文优先确保团队沟通效率、代码可维护性和业务理解的一致性。

### II. 代码即文档原则

**代码注释必须清晰、准确、完整地描述业务规则与逻辑。**

- 遵循 TSDoc 注释规范
- 所有公共 API、类、方法、接口、枚举都必须添加完整的 TSDoc 注释
- 注释必须包含：
  - `@description`: 功能描述和业务逻辑
  - `@param`: 参数说明（含业务含义）
  - `@returns`: 返回值说明
  - `@throws`: 异常情况说明
  - `@example`: 使用示例
  - 业务规则详细描述
  - 前置条件和后置条件
  - 使用场景和注意事项
- 代码变更时必须同步更新注释
- 详细规范见 `.cursor/constitutions/code-comment-standards.md`

**理由**：通过详细的注释让代码本身成为最好的业务文档，减少文档维护成本，提高团队协作效率，确保业务逻辑的准确传承。

### III. 架构原则

**项目采用混合架构模式：Clean Architecture + DDD + CQRS + 事件溯源 (ES) + 事件驱动架构 (EDA)**

- **Clean Architecture**：
  - 四层架构：领域层、应用层、基础设施层、接口层
  - 依赖关系从外向内，内层不依赖外层
  - 核心业务逻辑独立于框架和基础设施
  - 用例（Use Cases）必须在文档和设计中明确提及

- **领域驱动设计 (DDD)**：
  - **充血模型（Rich Domain Model）**：
    - 领域对象必须包含业务逻辑和数据，禁止使用贫血模型
    - 实体和聚合根必须封装业务行为，而非仅作为数据容器
    - 业务规则必须在领域对象内部实现，而非在服务层
    - 领域对象通过方法暴露行为，而非直接暴露属性
    - 对象状态变更必须通过业务方法，确保业务规则的执行
    - 禁止贫血模型（Anemic Domain Model）：领域对象只有 getter/setter 没有业务逻辑
  - **战术设计**：
    - 领域实体和聚合根必须分离（entities/ 和 aggregates/）
    - 聚合根管理聚合边界和一致性规则
    - 值对象（Value Objects）表示无标识的不可变概念
    - 领域服务（Domain Services）处理跨实体的领域逻辑
    - 仓储（Repositories）负责聚合的持久化
    - 规格模式（Specifications）封装复杂的业务规则
    - 领域事件（Domain Events）记录领域内发生的重要事实
  - **统一语言**：
    - 技术实现必须使用业务术语
    - 代码结构反映业务模型
    - 开发者和业务专家使用相同的术语交流

- **CQRS 模式**：
  - 命令（Command）和查询（Query）必须分离
  - 写操作使用命令模型，改变系统状态
  - 读操作使用查询模型，不改变状态
  - 支持读写模型的独立优化和扩展
  - 命令和查询通过总线（Bus）分发
  - 事件投影器（Projectors）构建读模型

- **事件溯源 (ES)**：
  - 所有状态变更通过事件记录，事件是事实来源
  - 事件是不可变的事实记录，只能追加不能修改
  - 支持通过重放事件重建聚合状态
  - 支持完整的审计追踪和时间旅行
  - 事件存储（Event Store）是核心基础设施
  - 快照（Snapshots）优化事件重放性能

- **事件驱动架构 (EDA)**：
  - 系统组件通过事件通信，实现松耦合
  - 领域事件在聚合内部传播
  - 集成事件在服务间传播
  - 支持异步处理和最终一致性
  - 事件总线（Event Bus）负责事件的发布和订阅
  - Saga 模式协调跨聚合的长事务

**理由**：混合架构模式为企业级SAAS平台提供高可扩展性、高性能、高可靠性和高可维护性。DDD 确保技术实现与业务需求一致；Clean Architecture 确保核心逻辑独立于技术；CQRS 支持读写分离和独立优化；事件溯源提供完整的审计追踪；事件驱动实现系统解耦。这些模式的有机结合，适应复杂的业务场景和未来微服务部署需求。详细目录结构见 `docs/backend-project-template.md`。

### IV. Monorepo 组织原则

**使用 Turborepo 管理多个相关项目，实现代码共享和独立部署**

- **项目结构**：
  - `apps/`: 应用程序项目
  - `libs/`: 服务端的业务库、领域模块、依赖库
  - `packages/`: 前端的业务库、组件库以及前后端共享的依赖库和工具包
  - `examples/`: 示例和演示项目
- **领域模块独立性**：
  - 领域模块作为独立项目开发
  - 便于未来微服务部署
  - 模块间通过明确的接口通信
- **服务模块命名**：
  - 服务模块放在 services 目录时，去掉 "-service" 后缀
  - 例如：`auth-service` → `auth`
- **包管理**：
  - 必须使用 pnpm 作为包管理工具
  - 通过 `pnpm-workspace.yaml` 管理项目依赖
  - 使用 `turbo run` 执行项目任务

**理由**：Monorepo 结构支持代码复用、统一配置管理和原子化提交，同时保持各模块的独立性，为微服务架构演进奠定基础。

### V. 质量保证原则

**确保代码质量、可维护性和可测试性**

- **ESLint 规范**：
  - 项目使用 `eslint.config.mjs` 作为配置文件
  - 子项目必须扩展并集成根目录的 ESLint 配置
  - 主动使用 MCP ESLint 工具进行代码检查和自动修复
- **TypeScript 配置**：
  - 每个 `libs/<package>/tsconfig.json` 必须扩展 monorepo 根 tsconfig.json
  - 确保配置一致性
- **文档规范**：
  - 详细设计文件使用 "XS" 前缀而非 "详细设计"
  - 保持文档与代码同步更新

**理由**：统一的质量标准和工具链确保代码库的长期可维护性，减少技术债务，提高团队协作效率。

### VI. 测试架构原则

**本项目遵循分层测试架构，确保代码质量和快速反馈**

- **就近原则**：单元测试文件与被测试文件在同一目录
  - 文件命名：`{被测试文件名}.spec.ts`
  - 便于维护和快速定位测试
  - 确保测试与代码同步更新

- **集中管理**：集成测试、端到端测试统一放置在 `__tests__` 目录
  - 集成测试：`__tests__/integration/`
  - 端到端测试：`__tests__/e2e/`
  - 便于统一管理和执行

- **类型分离**：不同类型的测试使用不同的目录结构
  - 单元测试：与源代码同目录
  - 集成测试：按模块组织在 `__tests__/integration/`
  - 端到端测试：按功能组织在 `__tests__/e2e/`

- **依赖隔离**：测试之间相互独立，不依赖执行顺序
  - 每个测试用例独立运行
  - 使用 beforeEach/afterEach 清理状态
  - 避免共享可变状态

- **快速反馈**：单元测试快速执行，集成测试覆盖关键路径
  - 单元测试：毫秒级执行
  - 集成测试：秒级执行
  - 端到端测试：分钟级执行

**测试金字塔**：

```text
           ┌─────────────────┐
           │   E2E Tests     │  ← 少量，覆盖关键用户流程
           │   (端到端测试)    │
           └─────────────────┘
        ┌─────────────────────┐
        │  Integration Tests  │  ← 适量，测试模块间交互
        │   (集成测试)         │
        └─────────────────────┘
     ┌─────────────────────────┐
     │     Unit Tests          │  ← 大量，测试单个组件
     │     (单元测试)           │
     └─────────────────────────┘
```

**测试覆盖率要求**：

- 核心业务逻辑测试覆盖率 ≥ 80%
- 关键路径测试覆盖率 ≥ 90%
- 所有公共 API 必须有对应的测试用例

**理由**：分层测试架构确保代码质量，减少缺陷，提供快速反馈，详细规范见 `docs/testing-standards.md`。

### VII. 数据隔离与共享原则

**系统必须实现多层级数据隔离，支持共享数据和非共享数据的细粒度访问控制**

这是企业级SAAS平台的核心安全能力，确保数据在正确的范围内访问，防止数据泄露。

#### 多层级数据隔离

基于宪章定义的统一语言体系，系统支持以下5个隔离层级：

- **平台级隔离（Platform Level）**：
  - 平台数据与租户数据完全隔离
  - 平台管理数据仅平台管理员可访问
  - 例如：平台配置、全局统计、系统监控数据

- **租户级隔离（Tenant Level）**：
  - 不同租户的数据完全隔离，这是最基础的隔离要求
  - 租户间数据不可跨访问，即使是相同类型的数据
  - 支持企业租户、社群租户、团队租户、个人租户四种类型
  - 例如：租户A的订单数据对租户B完全不可见

- **组织级隔离（Organization Level）**：
  - 同一租户内，不同组织的非共享数据相互隔离
  - 组织是租户内的横向管理单位（专业委员会、项目团队、质量小组等）
  - 组织间是平行关系，无从属关系
  - 例如：技术委员会的评审数据对市场委员会不可见

- **部门级隔离（Department Level）**：
  - 同一组织内，不同部门的非共享数据相互隔离
  - 部门是纵向管理单位，具有层级关系，支持8层嵌套
  - 部门间遵循上下级关系，上级部门可访问下级部门的共享数据
  - 例如：财务部门的预算数据对人力资源部门不可见

- **用户级隔离（User Level）**：
  - 用户私有数据仅该用户可访问
  - 即使在同一部门，用户私有数据也相互隔离
  - 例如：用户A的个人笔记对用户B不可见

#### 数据分类

系统将所有数据分为两类：

- **共享数据（Shared Data）**：
  - 可以在特定层级内被所有下级访问
  - 必须明确定义共享级别（平台共享、租户共享、组织共享、部门共享）
  - 共享数据对指定层级及其所有下级层级可见
  - 例如：租户级共享的公告，对该租户内所有组织、部门、用户可见

- **非共享数据（Non-Shared Data）**：
  - 仅限特定层级访问，不可跨层级访问
  - 数据所有者层级决定访问权限
  - 非共享数据是默认状态，确保数据安全
  - 例如：部门级非共享的财务数据，仅该部门成员可访问

#### 数据访问规则

- **隔离规则**：
  - 所有数据访问必须携带完整的隔离上下文（租户ID、组织ID、部门ID、用户ID）
  - 系统自动根据隔离上下文过滤数据，开发者无需手动处理
  - 跨层级数据访问必须经过明确授权
  - 所有数据访问都必须记录审计日志

- **共享规则**：
  - 上级层级的共享数据对下级可见（如租户共享数据对所有组织可见）
  - 下级层级的数据对上级不可见（除非明确授权）
  - 同级层级的非共享数据相互隔离
  - 数据的共享级别在创建时确定，可通过权限管理修改

- **兼职场景**：
  - 用户可以同时属于多个组织或部门（兼职）
  - 系统支持上下文切换，用户可选择当前工作的组织和部门
  - 用户可访问所有归属层级的数据，但同一时刻只能在一个上下文中操作

#### 技术实现要求

- **数据模型**：
  - 所有业务表必须包含隔离字段（tenantId、organizationId、departmentId、userId）
  - 必须为隔离字段创建索引以优化查询性能
  - 建议使用数据库行级安全策略（如 PostgreSQL RLS）

- **API设计**：
  - 所有API请求必须携带隔离标识（X-Tenant-Id、X-Organization-Id、X-Department-Id、X-User-Id）
  - API响应只包含当前隔离上下文有权访问的数据
  - 数据创建时必须指定共享级别和所有者层级

- **缓存策略**：
  - 缓存键必须包含完整的隔离层级信息
  - 支持基于层级的批量缓存失效
  - 例如：清除整个租户的缓存时，使用租户ID前缀匹配

- **审计追踪**：
  - 所有数据访问必须记录完整的隔离上下文
  - 跨层级数据访问必须触发审计事件
  - 数据访问拒绝必须记录原因和上下文

**理由**：多层级数据隔离是企业级SAAS平台的核心安全能力，确保数据在正确的范围内访问。通过统一的数据分类和访问规则，既保证了数据安全，又支持了灵活的数据共享需求，是实现细粒度权限控制的基础。

### VIII. 统一语言原则（Ubiquitous Language）

**所有团队成员（开发者、AI助手、业务人员）必须使用统一的领域术语进行沟通和文档编写**

这是领域驱动设计（DDD）的核心原则之一，确保技术实现与业务需求的一致性。

#### 核心术语定义

本项目使用的核心术语及其定义参见 `docs/definition-of-terms.mdc`，以下是关键术语摘要：

##### 平台 (Platform)

- **定义**：平台是SAAS服务的提供商，负责开发系统、提供技术支持和通用的商业服务
- **主要职责**：
  - 系统开发和维护
  - 技术支持和问题解决
  - 提供通用的商业服务和管理功能
  - 平台运营和监控
  - 租户管理和用户管理
- **服务对象**：平台管理员、个人用户、租户、租户用户
- **特点**：提供多租户SAAS服务，支持多种租户类型，提供完整的用户管理体系和权限控制

##### 租户 (Tenant)

- **定义**：租户是SAAS平台中的独立客户单位，拥有独立的数据空间和配置环境
- **类型**：
  - **企业租户**：公司、集团等商业组织
  - **社群租户**：社区、协会、俱乐部等社会组织
  - **团队租户**：项目团队、工作组等临时性组织
  - **个人租户**：个人用户创建的独立空间
- **特点**：数据完全隔离、独立的配置环境、独立的用户管理、独立的权限体系

##### 组织 (Organization)

- **定义**：组织是租户内设的横向部门管理单位，负责管理下属部门的特定职能及业务
- **类型**：专业委员会、项目管理团队、质量控制小组、绩效管理小组、其他职能组织
- **特点**：
  - 横向设置，组织之间没有从属关系
  - 专注于特定职能或业务领域
  - 可以管理多个部门
  - 具有相对独立的管理权限

##### 部门 (Department)

- **定义**：部门是组织内设的纵向管理机构，具有明确的上下级从属关系
- **特点**：
  - 纵向设置，具有明确的层级关系
  - 上级部门管理下级部门
  - 具有明确的汇报关系
  - 负责具体的业务执行
- **层级关系**：支持多级部门嵌套，可达8层以上（总部 → 事业部 → 区域 → 分公司 → 部门 → 组 → 小组 → 专项团队）

##### 用户 (User)

- **定义**：用户是SAAS平台的使用者，是系统中最基本的身份单位
- **分类方法**：
  - **按用户来源分类**：平台用户、租户用户、系统用户
  - **按用户类型分类**：个人用户、企业用户、社群用户、团队用户
  - **按用户角色分类**：管理员用户、普通用户、系统用户
  - **按用户状态分类**：活跃用户、待激活用户、禁用用户、锁定用户、过期用户
  - **按用户归属分类**：平台级用户、租户级用户、组织级用户、部门级用户
- **特点**：
  - 用户首先属于平台
  - 用户可以被分配到租户
  - 租户用户可以被分配到组织和部门
  - 用户可以同时属于多个组织和部门（兼职）
  - 用户离开租户后仍然是平台用户

#### 术语关系图

```text
平台 (Platform) - SAAS服务提供商
├── 平台管理员
├── 个人用户 (Personal User)
│
└── 租户 (Tenant) - 平台客户
    ├── 企业租户
    ├── 社群租户
    ├── 团队租户
    └── 个人租户
        │
        ├── 组织 (Organization) - 横向设置
        │   ├── 专业委员会
        │   ├── 项目管理团队
        │   ├── 质量控制小组
        │   └── 绩效管理小组
        │
        └── 部门 (Department) - 纵向设置
            ├── 一级部门
            │   ├── 二级部门
            │   │   └── 三级部门
            │   └── 二级部门
            └── 一级部门
```

#### 术语使用规范

- **一致性**：在所有文档、代码注释、接口定义、数据模型中使用统一术语
- **精确性**：使用术语时必须符合其定义，不得随意扩展或改变含义
- **可追溯性**：技术实现必须能够追溯到业务术语，代码中的实体、服务、方法命名应反映业务术语
- **演进性**：术语定义会随业务发展而演进，术语变更必须同步更新到所有相关文档和代码

#### 核心业务实体映射

基于统一语言，系统需要支持以下核心业务实体：

**平台级实体**：

- Platform（平台）
- PlatformUser（平台用户）
- PlatformAdmin（平台管理员）

**租户级实体**：

- Tenant（租户）
  - EnterpriseTenant（企业租户）
  - CommunityTenant（社群租户）
  - TeamTenant（团队租户）
  - PersonalTenant（个人租户）
- TenantUser（租户用户）

**组织级实体**：

- Organization（组织）
  - Committee（专业委员会）
  - ProjectTeam（项目管理团队）
  - QualityGroup（质量控制小组）
  - PerformanceGroup（绩效管理小组）

**部门级实体**：

- Department（部门）
  - Level1Department（一级部门）
  - Level2Department（二级部门）
  - Level3Department（三级部门）

**用户实体**：

- User（用户基础实体）
- UserRole（用户角色）
- UserStatus（用户状态）
- UserPermission（用户权限）

#### 业务关系映射

**层级关系**：

- Platform → Tenant → Organization → Department
- User → TenantUser → OrganizationUser → DepartmentUser

**多对多关系**：

- User 可以属于多个 Tenant
- User 可以属于多个 Organization
- User 在同一个 Organization 中只能属于一个 Department
- User 可以属于不同 Organization 的不同 Department
- Organization 可以管理多个 Department

#### 权限体系映射

**权限层级**：

- PlatformAdmin（平台管理员）
- TenantAdmin（租户管理员）
- OrganizationAdmin（组织管理员）
- DepartmentAdmin（部门管理员）
- RegularUser（普通用户）

**权限继承**：

- 上级权限包含下级权限
- 跨层级权限需要特殊授权
- 兼职用户权限需要合并处理

**理由**：统一语言是领域驱动设计的基石，确保业务专家和技术团队使用相同的术语交流，避免翻译损失，提高沟通效率，确保技术实现准确反映业务需求。详细术语定义见 `docs/definition-of-terms.mdc`。

### IX. TypeScript `any` 类型使用原则

**`any` 类型应被视为"逃生舱口"而非常规工具，在"危险的潜在性"与"安全的宽泛性"之间保持严格的平衡**

TypeScript 的 `any` 类型具有两面性：它禁用类型检查带来潜在危险，但在某些高级场景中又是实现预期行为的必要手段。

#### 危险的潜在性

- **失去类型安全**：`any` 禁用 TypeScript 的类型检查和自动完成特性
- **运行时风险**：编译时不报错的代码可能在运行时崩溃
- **维护困难**：失去类型推导使代码难以理解和重构
- **技术债务**：过度使用 `any` 会降低整个代码库的质量

#### 安全的宽泛性

在以下特定场景中，`any` 的使用是必要且安全的：

- **泛型约束中的函数类型**：
  - 使用 `(...args: any[]) => any` 作为泛型约束
  - 使类型工具能够适配任意函数签名
  - 例如：`type ReturnType<T extends (...args: any[]) => any>`

- **高阶函数和装饰器**：
  - 声明对参数类型不关心的高阶函数
  - 保持函数装饰器的通用性和灵活性
  - 需要配合 `Parameters<T>` 和 `ReturnType<T>` 使用

- **条件类型和类型推断**：
  - 在复杂的条件类型中处理类型推断
  - 使用 `infer` 关键字配合 `any` 实现高级类型转换
  - 需要明确的类型断言保证正确性

- **第三方库集成**：
  - 与不使用 TypeScript 的第三方库集成
  - 处理动态 JSON 数据（配合类型保护函数）
  - 必须配合类型保护函数确保安全

#### 安全使用规则

- **明确声明**：
  - 使用 `any` 时必须添加注释说明原因
  - 注释格式：`// eslint-disable-next-line @typescript-eslint/no-explicit-any -- 原因说明`
  - 必须解释为什么其他类型（如 `unknown`）不适用

- **局部限定**：
  - 将 `any` 的使用限制在最小范围内
  - 尽快将 `any` 转换为具体类型
  - 避免 `any` 在函数签名中传播

- **测试保障**：
  - 使用 `any` 的代码必须有 ≥ 90% 的测试覆盖率
  - 编写测试验证运行时行为的正确性
  - 测试各种边界情况和异常输入

- **优先替代方案**：
  - 优先使用 `unknown` 并配合类型保护函数
  - 优先使用泛型约束而非 `any`
  - 优先使用联合类型或交叉类型
  - 只有在上述方案都不适用时才使用 `any`

- **持续改进**：
  - 定期审查代码库中的 `any` 使用
  - 使用类型保护函数逐步收窄类型
  - 记录和监控 `any` 使用情况

#### 工程化约束

- **ESLint 配置**：
  - 必须启用 `@typescript-eslint/no-explicit-any` 规则（error 级别）
  - 必须启用 `@typescript-eslint/no-unsafe-*` 系列规则
  - 测试文件中可以降低为 warning 级别
  - 所有生产代码严格执行，不提供宽松配置

- **代码审查要求**：
  - 所有新增的 `any` 使用必须在代码审查中说明理由
  - 审查者必须验证是否存在更安全的替代方案
  - 必须确认相应的测试覆盖率

- **度量和监控**：
  - 定期统计代码库中 `any` 的使用数量
  - 设置 `any` 使用比例的上限目标（< 1%）
  - 所有代码（包括新代码和现有代码）禁止引入新的 `any`（除非充分说明理由）
  - 项目处于重新开发初期，所有代码都是新代码，必须严格遵循

#### 典型使用模式

**✅ 推荐模式 - 泛型约束**：

```typescript
// 声明对函数参数类型不关心的泛型约束
type ReturnType<T extends (...args: any[]) => any> = 
  T extends (...args: any[]) => infer R ? R : never;
```

**✅ 推荐模式 - 配合测试**：

```typescript
function parseJSON<T = unknown>(json: string): T {
  try {
    return JSON.parse(json) as T;
  } catch {
    return null as any; // 配合单元测试验证行为
  }
}
```

**❌ 禁止模式 - 懒惰使用**：

```typescript
// 不可接受：仅为避免类型错误而使用 any
function process(data: any): any {
  return data.value; // 应该使用 unknown 或具体类型
}
```

**理由**：TypeScript 的类型系统是代码质量的重要保障，`any` 的过度使用会破坏这一保障。通过明确的规则和约束，在保持类型安全的同时，为必要的灵活性提供"逃生舱口"，实现安全性与实用性的平衡。详细说明见 `docs/any-except.md`。

## 技术约束

### 技术栈要求

**运行环境和开发工具：**

- **运行环境**：Node.js >= 20
- **开发语言**：TypeScript 5.9.2
- **包管理器**：pnpm 10.11.0
- **构建工具**：Turborepo 2.5.8
- **代码格式化**：Prettier 3.6.2
- **后端框架**：NestJS（推荐）
- **架构模式**：Clean Architecture + CQRS + ES + EDA

### TypeScript 配置要求（服务端项目）

**所有服务端项目（apps/、libs/ 中的 NestJS 项目）必须使用 NodeNext 模块系统**

#### 核心配置

所有服务端项目的 `tsconfig.json` 必须包含以下关键配置：

```json
{
  "compilerOptions": {
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "target": "ES2022",
    "moduleDetection": "force",
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "skipLibCheck": true
  }
}
```

#### 必需配置项说明

- **module: "NodeNext"**：
  - 使用现代 Node.js 模块系统
  - 支持 ES 模块标准
  - 更好的 Tree Shaking 和打包优化
  - 与前端生态系统保持一致

- **moduleResolution: "NodeNext"**：
  - 使用 Node.js 的模块解析算法
  - 正确处理 package.json 的 exports 字段
  - 支持条件导出和子路径导出

- **target: "ES2022"**：
  - 目标运行环境为现代 Node.js（>= 20）
  - 支持最新的 JavaScript 特性
  - 无需额外的 polyfill

- **moduleDetection: "force"**：
  - 强制所有文件视为模块
  - 避免全局作用域污染
  - 确保模块隔离性

- **esModuleInterop: true**：
  - 允许使用 `import` 导入 CommonJS 模块
  - 提升与第三方库的兼容性
  - 简化导入语法

- **strict: true**：
  - 启用所有严格类型检查选项
  - 确保最高级别的类型安全
  - 包括 strictNullChecks、strictFunctionTypes 等

- **skipLibCheck: true**：
  - 跳过 .d.ts 文件的类型检查
  - 提升编译性能
  - 避免第三方库类型定义的问题

#### package.json 对应配置

所有服务端项目的 `package.json` 必须包含：

```json
{
  "type": "module",
  "engines": {
    "node": ">=20"
  }
}
```

- **type: "module"**：声明项目使用 ES 模块
- **engines**：确保运行环境满足要求

#### 配置继承要求

- 所有服务端项目的 `tsconfig.json` 必须继承共享配置（如 `@repo/ts-config/nestjs.json`）
- 仅在必要时添加项目特定配置（如 `paths`、`outDir`）
- 禁止覆盖核心配置项（module、moduleResolution、strict）

#### 禁止使用 CommonJS

**不允许在新的服务端项目中使用以下配置**：

```json
{
  "compilerOptions": {
    "module": "CommonJS",        // ❌ 禁止
    "moduleResolution": "node"   // ❌ 禁止
  }
}
```

**理由**：

- CommonJS 是过时的模块系统
- 不支持现代 JavaScript 特性
- 性能优化有限
- 与前端生态系统不一致
- 项目处于重新开发初期，无需向后兼容

**例外情况**：

- 仅在与特定第三方库集成时遇到兼容性问题，且无法解决时，可以在特定文件中使用 CommonJS
- 必须在代码审查中说明理由
- 必须制定迁移到 ES 模块的计划

#### 文件扩展名规范

- **TypeScript 源文件**：使用 `.ts` 扩展名
- **ES 模块 JavaScript**：使用 `.mjs` 扩展名（配置文件）
- **类型声明文件**：使用 `.d.ts` 扩展名

#### 导入导出规范

- 必须使用 ES 模块语法：`import` / `export`
- 禁止使用 `require()` / `module.exports`（除非在配合特定第三方库时）
- 导入第三方模块必须包含文件扩展名（如需要）

**理由**：NodeNext 模块系统代表了 Node.js 的未来方向，提供更好的现代化支持、性能优化和生态系统兼容性。统一使用 NodeNext 确保所有服务端项目的一致性，便于维护和升级。详细说明见 `docs/ts-config.md`。

### 编译工具要求（服务端项目）

**所有服务端项目必须联合使用 TypeScript (tsc) 和 SWC，实现类型检查与快速编译的平衡**

#### 编译策略

- **TypeScript (tsc)**：用于类型检查
  - 在开发阶段运行类型检查
  - 在 CI/CD 流程中强制类型检查
  - 生成类型声明文件（.d.ts）
  - 确保类型安全

- **SWC**：用于生产环境的快速编译
  - 在开发阶段用于热重载（watch 模式）
  - 在生产构建时快速编译代码
  - 显著提升编译速度（比 tsc 快 20-70 倍）
  - 不进行类型检查，纯粹的代码转换

#### 构建脚本规范

所有服务端项目的 `package.json` 必须包含以下脚本：

```json
{
  "scripts": {
    "build": "nest build && tsc --noEmit",
    "build:swc": "nest build -b swc && tsc --noEmit",
    "dev": "nest start -b swc -w",
    "type-check": "tsc --noEmit"
  }
}
```

**脚本说明**：

- `build`：默认构建，使用 tsc 编译并类型检查
- `build:swc`：生产环境快速构建，使用 swc 编译 + tsc 类型检查
- `dev`：开发模式，使用 swc 热重载
- `type-check`：独立的类型检查，不生成文件

#### CI/CD 流程要求

在持续集成流程中，必须执行以下步骤：

```yaml
# 示例 GitHub Actions workflow
- name: Type Check
  run: pnpm type-check
  
- name: Build
  run: pnpm build:swc
  
- name: Lint
  run: pnpm lint
  
- name: Test
  run: pnpm test
```

**关键原则**：

- 类型检查必须独立执行，不依赖编译过程
- 生产构建使用 swc 提升速度，但必须配合 tsc 类型检查
- 类型检查失败必须阻塞构建流程

#### 配置文件要求

**tsconfig.json**：

```json
{
  "compilerOptions": {
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "target": "ES2022",
    "strict": true,
    // ... 其他宪章要求的配置
    "noEmit": false  // tsc 用于生成类型声明
  }
}
```

**tsconfig.build.json**（可选）：

```json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": true  // 仅类型检查，不生成文件
  },
  "exclude": ["**/*.spec.ts", "**/*.test.ts", "__tests__"]
}
```

**.swcrc**（NestJS 项目）：

NestJS CLI 会自动使用 swc，通过 `-b swc` 参数启用。无需额外配置文件。

#### 性能对比

- **tsc 编译时间**：通常需要 10-30 秒（中型项目）
- **swc 编译时间**：通常需要 1-3 秒（相同项目）
- **类型检查时间**：3-10 秒（使用 `tsc --noEmit`）

**总体收益**：

- 开发体验：swc 热重载快速响应
- 生产构建：swc 编译 + tsc 类型检查（总时间约为纯 tsc 的 30-50%）
- 类型安全：保持 100% 的类型检查覆盖

#### 最佳实践

- **开发阶段**：使用 `pnpm dev`（swc watch 模式），快速热重载
- **提交前**：运行 `pnpm type-check`，确保类型安全
- **生产构建**：使用 `pnpm build:swc`，快速编译 + 类型检查
- **CI/CD**：独立运行 `type-check`、`lint`、`test`、`build:swc`

**理由**：联合使用 tsc 和 swc 实现了类型安全与开发效率的最佳平衡。tsc 确保严格的类型检查，swc 提供极快的编译速度，特别适合大型 monorepo 项目。这种策略在保证代码质量的同时，显著提升了开发体验和 CI/CD 效率。

### 配置管理

**配置文件位置和继承规则：**

- **配置文件位置**：
  - 根目录：全局配置（ESLint、TypeScript、Prettier、Turborepo）
  - 子项目：扩展并定制根配置
- **配置继承原则**：
  - 子项目配置必须继承根配置
  - 仅在必要时添加项目特定配置
  - 避免配置碎片化

### 性能和可扩展性

**系统设计要求：**

- **水平扩展**：系统设计必须支持水平扩展
- **缓存策略**：合理使用缓存提升性能
- **数据库**：支持读写分离和分库分表
- **消息队列**：使用消息队列实现异步处理和解耦

## 开发工作流

### 工作目录规范

- **命令执行位置**：
  - 所有命令必须在 monorepo 根路径执行：`/home/arligle/hl8/hl8-saas-platform-turborepo`
  - 使用相对路径或绝对路径进入子项目目录
  - 示例：`cd /home/arligle/hl8/hl8-saas-platform-turborepo && cd packages/auth && pnpm build`
- **避免直接切换**：
  - 不要直接切换到子项目目录
  - 确保命令执行的上下文正确性

### MCP 工具优先

- **主动使用 MCP 工具**：
  - 优先使用可用的 MCP 工具处理任务
  - MCP 工具比手动操作更准确、更高效
- **可用工具**：
  - `eslint_lint_files`: 检查代码质量和规范
  - `eslint_fix_files`: 自动修复代码问题
  - Nx MCP 工具：项目管理和文档查询

### 代码变更流程

1. **需求分析**：明确业务需求和技术方案，使用统一术语描述
2. **架构设计**：遵循 Clean Architecture + CQRS + ES + EDA
3. **接口定义**：设计清晰的模块接口，使用统一术语命名
4. **实现开发**：编写符合规范的代码和注释，使用统一术语
5. **质量检查**：运行 ESLint、TypeScript 检查
6. **测试验证**：执行单元测试和集成测试
7. **代码审查**：团队成员审查代码和注释，验证术语使用一致性
8. **文档更新**：同步更新相关文档，使用统一术语

### 代码审查要求

- **注释审查**：
  - 验证 TSDoc 注释完整性
  - 检查业务规则描述准确性
  - 确认中文注释清晰度
  - 验证统一术语使用的一致性
- **架构审查**：
  - 验证是否符合架构原则
  - 检查依赖方向是否正确
  - 确认模块边界清晰
  - 验证业务实体映射的准确性
- **质量审查**：
  - 运行 ESLint 检查
  - 验证类型安全
  - 检查测试覆盖率

## 治理规范

### 宪章效力

- 本宪章优先于所有其他实践和规范
- 所有 PR 和代码审查必须验证是否符合宪章要求
- 任何复杂性必须有充分理由并在文档中说明

### 修订流程

1. **提议修订**：团队成员提出修订建议，说明理由和影响
2. **影响评估**：评估修订对现有代码和流程的影响
3. **团队讨论**：团队讨论修订的必要性和合理性
4. **批准决策**：技术负责人批准修订
5. **版本更新**：按语义化版本规则更新版本号
6. **文档同步**：更新所有相关文档和模板
7. **团队通知**：通知团队成员修订内容

### 版本控制

**版本格式**：MAJOR.MINOR.PATCH

- **MAJOR（主版本）**：不向后兼容的治理/原则移除或重新定义
- **MINOR（次版本）**：新增原则/章节或重要扩展
- **PATCH（修订版）**：澄清说明、措辞优化、错误修复

### 合规性审查

- **定期审查**：每季度审查宪章执行情况
- **违规处理**：记录违规情况，分析原因，制定改进措施
- **持续改进**：根据实践反馈优化宪章内容

### 运行时指导

- 开发过程中参考 `.cursor/rules/pre-rule.mdc` 获取运行时开发指导
- 使用 `.cursor/constitutions/code-comment-standards.md` 作为注释规范详细指南
- 使用 `docs/definition-of-terms.mdc` 作为统一语言和术语定义参考

---

**版本**: 1.5.0 | **批准日期**: 2025-10-10 | **最后修订**: 2025-10-11
